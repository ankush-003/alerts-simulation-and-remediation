package main

import (
	"encoding/json"
	"fmt"
	"time"

	//"rule_engine_demo/mongo"
	"context"

	"github.com/hyperjumptech/grule-rule-engine/ast"
	"github.com/hyperjumptech/grule-rule-engine/builder"
	"github.com/hyperjumptech/grule-rule-engine/engine"
	"github.com/hyperjumptech/grule-rule-engine/logger"
	"github.com/hyperjumptech/grule-rule-engine/pkg"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

type InputData struct {
	ID          string    json:"id"
	Name        string    json:"name"
	Type        string    json:"type"
	Description string    json:"desc"
	Severity    string    json:"severity"
	Origin      string    json:"origin"
	CreatedAt   time.Time json:"createdAt"
}

type AlertContext struct {
	AlertInput  *InputData
	AlertOutput *OutputData
}

func (ac *AlertContext) RuleName() string {
	return "Alerts"
}

func (ac *AlertContext) RuleInput() RuleInput {
	return ac.AlertInput
}

func (ac *AlertContext) RuleOutput() RuleOutput {
	return ac.AlertOutput
}

// User data attributes
func (id *InputData) DataKey() string {
	return "InputData"
}

// Offer output object
type OutputData struct {
	Remedy string josn:"remedy"
}

func (od *OutputData) DataKey() string {
	return "OutputData"
}

func NewAlertContext() *AlertContext {
	return &AlertContext{
		AlertInput:  &InputData{},
		AlertOutput: &OutputData{},
	}
}

var knowledgeLibrary = *ast.NewKnowledgeLibrary()

// Rule input object
type RuleInput interface {
	DataKey() string
}

// Rule output object
type RuleOutput interface {
	DataKey() string
}

// configs associated with each rule
type RuleConfig interface {
	RuleName() string
	RuleInput() RuleInput
	RuleOutput() RuleOutput
}

type RuleEngineSvc struct {
}

func NewRuleEngineSvc() *RuleEngineSvc {
	// you could add your cloud provider here instead of keeping rule file in your code.
	buildRuleEngine()
	return &RuleEngineSvc{}
}

type Rule struct {
	Name        string   json:"name" bson:"name"
	Description string   json:"desc" bson:"desc"
	Salience    int32    json:"salience" bson:"salience"
	When        string   json:"when" bson:"when"
	Then        []string json:"then" bson:"then"
}

func buildRuleEngine() {
	ruleBuilder := builder.NewRuleBuilder(&knowledgeLibrary)

	client, err := mongo.NewClient(options.Client().ApplyURI("mongodb+srv://pes1202102575:Shreya2003@cluster0.m1lej8m.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0"))
	if err != nil {
		panic(err)
	}

	ctx, cancel := context.WithTimeout(context.Background(), 120*time.Second)
	defer cancel()

	err = client.Connect(ctx)
	if err != nil {
		panic(err)
	}
	defer client.Disconnect(ctx)

	db := client.Database("rules_sample1")
	collection := db.Collection("grules_sample")
	curr, err := collection.Find(ctx, bson.M{}, options.Find().SetProjection(bson.D{{Key: "_id", Value: 0}}))
	if err != nil {
		panic(err)
	}
	var results []bson.M
	curr.All(ctx, &results)
	rules, err := json.Marshal(results)
	if err != nil {
		panic(err)
	}

	ruleset, _ := pkg.ParseJSONRuleset(rules)
	fmt.Println(ruleset)
	ruleFile := pkg.NewBytesResource([]byte(ruleset))
	err = ruleBuilder.BuildRuleFromResource("Rules", "0.0.1", ruleFile)

	if err != nil {
		fmt.Println("Error: ", err)
		panic(err)
	}

}

func (svc *RuleEngineSvc) Execute(ruleConf RuleConfig) error {
	// get KnowledgeBase instance to execute particular rule
	knowledgeBase, _ := knowledgeLibrary.NewKnowledgeBaseInstance("Rules", "0.0.1")

	dataCtx := ast.NewDataContext()
	// add input data context
	err := dataCtx.Add(ruleConf.RuleInput().DataKey(), ruleConf.RuleInput())
	if err != nil {
		return err
	}

	// add output data context
	err = dataCtx.Add(ruleConf.RuleOutput().DataKey(), ruleConf.RuleOutput())
	if err != nil {
		return err
	}

	// create rule engine and execute on provided data and knowledge base
	ruleEngine := engine.NewGruleEngine()
	err = ruleEngine.Execute(dataCtx, knowledgeBase)

	ruleEngine.MaxCycle = 40000

	if err != nil {
		return err
	}
	return nil
}

type Alert struct {
	ID          string    json:"id"
	Name        string    json:"name"
	Type        string    json:"type"
	Description string    json:"desc"
	Severity    string    json:"severity"
	Origin      string    json:"origin"
	CreatedAt   time.Time json:"createdAt"
	Remedy      string    json:"remedy"
}

// can be moved to offer directory
type OfferService interface {
	getRemedyForAlert(user Alert) string
}

type OfferServiceClient struct {
	ruleEngineSvc *RuleEngineSvc
}

func NewOfferService(ruleEngineSvc *RuleEngineSvc) OfferService {
	return &OfferServiceClient{
		ruleEngineSvc: ruleEngineSvc,
	}
}

func (svc OfferServiceClient) getRemedyForAlert(user Alert) string {
	ruleContext := NewAlertContext()
	ruleContext.AlertInput = &InputData{
		ID:          user.ID,
		Name:        user.Name,
		Type:        user.Type,
		Description: user.Description,
		Severity:    user.Severity,
		Origin:      user.Origin,
		CreatedAt:   user.CreatedAt,
	}

	err := svc.ruleEngineSvc.Execute(ruleContext)
	if err != nil {
		logger.Log.Error("get user offer rule engine failed", err)
	}

	return ruleContext.AlertOutput.Remedy
}

func main() {
	ruleEngineSvc := NewRuleEngineSvc()
	offerSvc := NewOfferService(ruleEngineSvc)

	userA := Alert{
		ID:          "1",
		Name:        "Memory Alert",
		Type:        "Memory",
		Description: "Ram usage is above 80%",
		Severity:    "Critical",
		Origin:      "Computer FS",
		CreatedAt:   time.Now(),
	}

	fmt.Println("Remedy for Alert A: ", offerSvc.getRemedyForAlert(userA))

	userB := Alert{
		ID:          "2",
		Name:        "Network Alert",
		Type:        "Computer Filesystem",
		Description: "Disk space is low, used > 75%",
		Severity:    "Warning",
		Origin:      "Computer Filesystem",
		CreatedAt:   time.Now(),
	}

	fmt.Println("Remedy for Alert B: ", offerSvc.getRemedyForAlert(userB))
}
